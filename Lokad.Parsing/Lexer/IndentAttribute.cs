using System;

namespace Lokad.Parsing.Lexer
{
    /// <summary> Marks a token as being an indent token. </summary>
    /// <remarks>
    ///     Unlike normal tokens, which are generated by matching a specific 
    ///     sequence of characters in the input string, the indent and 
    ///     <see cref="DedentAttribute"/> tokens are generated in packets. 
    ///     They have a length of zero and appear right before the  
    ///     (non-whitespace) character that confirmed the presence of dedents
    ///     or indents.
    /// 
    ///     Every time a newline, not ignored by a tokenizer feature that 
    ///     can ignore a newline, is followed by white-space, the size of that 
    ///     white-space prefix is compared with the length of the currently 
    ///     active indent. 
    ///     
    ///     If it is longer, the active indent is pushed onto a stack, an 
    ///     indent token is generated and the new indent becomes active. 
    /// 
    ///     If it is shorter, then indents are popped from the stack until 
    ///     one of them has the same length, and one dedent token is generated 
    ///     for each. If the stack contains no equal indent, the largest indent 
    ///     smaller than the new one is kept, and an indent token is generated 
    ///     afterwards. The indent stack is emptied before end-of-stream.
    /// </remarks>
    /// <example><code>A [end-of-line] [indent: 0 -> 2]
    /// ..B [end-of-line] [indent: 2 -> 4]
    /// ....C [end-of-line] [dedent: 4 -> 2]
    /// ..D [end-of-line] [indent: 2 -> 5]
    /// .....E [end-of-line] [dedent: 5 -> 2] [dedent: 2 -> 0]
    /// F [end-of-line] [indent: 0 -> 2]
    /// ..H [end-of-line] [dedent: 2 -> 0] [indent: 0 -> 1]
    /// .I [end-of-line] [dedent: 1 -> 0] [end-of-stream]
    /// </code></example>
    public sealed class IndentAttribute : Attribute { }
}
